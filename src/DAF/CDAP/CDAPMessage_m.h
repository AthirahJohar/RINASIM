//
// Generated file, do not edit! Created by opp_msgc 4.4 from DAF/CDAP/CDAPMessage.msg.
//

#ifndef _CDAPMESSAGE_M_H_
#define _CDAPMESSAGE_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0404
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif



/**
 * Enum generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum opCode_t {
 * 	M_CONNECT = 0;
 * 	M_CONNECT_R = 1;
 * 	M_RELEASE = 2;
 * 	M_RELEASE_R = 3;
 * 	M_CREATE = 4;
 * 	M_CREATE_R = 5;
 * 	M_DELETE = 6;
 * 	M_DELETE_R = 7;
 * 	M_READ = 8;
 * 	M_READ_R = 9;
 * 	M_CANCELREAD = 10;
 * 	M_CANCELREAD_R = 11;
 * 	M_WRITE = 12;
 * 	M_WRITE_R = 13;
 * 	M_START = 14;
 * 	M_START_R = 15;
 * 	M_STOP = 16;
 * 	M_STOP_R = 17;
 * }
 * </pre>
 */
enum opCode_t {
    M_CONNECT = 0,
    M_CONNECT_R = 1,
    M_RELEASE = 2,
    M_RELEASE_R = 3,
    M_CREATE = 4,
    M_CREATE_R = 5,
    M_DELETE = 6,
    M_DELETE_R = 7,
    M_READ = 8,
    M_READ_R = 9,
    M_CANCELREAD = 10,
    M_CANCELREAD_R = 11,
    M_WRITE = 12,
    M_WRITE_R = 13,
    M_START = 14,
    M_START_R = 15,
    M_STOP = 16,
    M_STOP_R = 17
};

/**
 * Enum generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum flagValues_t {
 * 	F_SYNC = 1;						
 * 	F_RD_INCOMPLETE = 2;			
 * }
 * </pre>
 */
enum flagValues_t {
    F_SYNC = 1,
    F_RD_INCOMPLETE = 2
};

/**
 * Enum generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum authTypes_t {
 * 	AUTH_NONE = 0;					
 * 	AUTH_PASSWD = 1;				
 * 	AUTH_SSHRSA = 2;				
 * 	AUTH_SSHDSA = 3;				
 * }
 * </pre>
 */
enum authTypes_t {
    AUTH_NONE = 0,
    AUTH_PASSWD = 1,
    AUTH_SSHRSA = 2,
    AUTH_SSHDSA = 3
};

/**
 * Enum generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum resultVal_t {
 * 	R_CLASSNOTFOUND = -5;
 * 	R_OBJBADINST = -4;
 * 	R_OBJNOTFOUND = -3;
 * 	R_OS_ERR = -2;
 * 	R_FAIL = -1;
 * 	R_SUCCESS = 0;
 * 	R_SYNC_UNIMP = 1;
 * 	R_FILTER_FALSE = 2;
 * 	R_FILTER_MIXED = 3;
 * }
 * </pre>
 */
enum resultVal_t {
    R_CLASSNOTFOUND = -5,
    R_OBJBADINST = -4,
    R_OBJNOTFOUND = -3,
    R_OS_ERR = -2,
    R_FAIL = -1,
    R_SUCCESS = 0,
    R_SYNC_UNIMP = 1,
    R_FILTER_FALSE = 2,
    R_FILTER_MIXED = 3
};

/**
 * Enum generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * enum absSyntax_t {
 * 	GPB = 0x08;
 * }
 * </pre>
 */
enum absSyntax_t {
    GPB = 0x08
};

/**
 * Struct generated from DAF/CDAP/CDAPMessage.msg by opp_msgc.
 */
struct objVal_t
{
    objVal_t();
    uint32 intval;
    int32 sintval;
    uint64 int64val;
    int64 sint64val;
    opp_string strval;
    float floatval;
    double doubleval;
};

void doPacking(cCommBuffer *b, objVal_t& a);
void doUnpacking(cCommBuffer *b, objVal_t& a);

/**
 * Struct generated from DAF/CDAP/CDAPMessage.msg by opp_msgc.
 */
struct authValue_t
{
    authValue_t();
    opp_string authName;
    opp_string authPassword;
    opp_string authOther;
};

void doPacking(cCommBuffer *b, authValue_t& a);
void doUnpacking(cCommBuffer *b, authValue_t& a);

/**
 * Struct generated from DAF/CDAP/CDAPMessage.msg by opp_msgc.
 */
struct result_t
{
    result_t();
    opp_string resultReason;
    int resultValue;
};

void doPacking(cCommBuffer *b, result_t& a);
void doUnpacking(cCommBuffer *b, result_t& a);

/**
 * Struct generated from DAF/CDAP/CDAPMessage.msg by opp_msgc.
 */
struct auth_t
{
    auth_t();
    unsigned char authType;
    authValue_t authValue;
};

void doPacking(cCommBuffer *b, auth_t& a);
void doUnpacking(cCommBuffer *b, auth_t& a);

/**
 * Struct generated from DAF/CDAP/CDAPMessage.msg by opp_msgc.
 */
struct naming_t
{
    naming_t();
    opp_string AEInst;
    opp_string AEName;
    opp_string ApInst;
    opp_string ApName;
};

void doPacking(cCommBuffer *b, naming_t& a);
void doUnpacking(cCommBuffer *b, naming_t& a);

/**
 * Struct generated from DAF/CDAP/CDAPMessage.msg by opp_msgc.
 */
struct object_t
{
    object_t();
    opp_string objectClass;
    opp_string objectName;
    int objectInstance;
    cObject objectVal;
};

void doPacking(cCommBuffer *b, object_t& a);
void doUnpacking(cCommBuffer *b, object_t& a);

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_General_Message {
 * 	unsigned char absSyntax enum(absSyntax_t);	
 * 	unsigned char opCode enum(opCode_t);		
 * 	uint32 invokeID;							
 * 	unsigned char flags enum(flagValues_t);		
 * 	string objClass;							
 * 	string objName;								
 * 	uint64 objInst;								
 * 	objVal_t objValue;							
 * 	uint32 result; 								
 * 	uint32 scope;								
 * 
 * 	unsigned char authMech enum(authTypes_t);	
 * 	authValue_t authValue;						
 * 	string destAEInst;							
 * 	string destAEName;							
 * 	string destApInst;							
 * 	string destApName;							
 * 	string srcAEInst;							
 * 	string srcAEName;							
 * 	string srcApInst;							
 * 	string srcApName;							
 * 	string resultReason;						
 * 	int64 version;								
 * }
 * </pre>
 */
class CDAP_General_Message : public ::cMessage
{
  protected:
    unsigned char absSyntax_var;
    unsigned char opCode_var;
    uint32 invokeID_var;
    unsigned char flags_var;
    opp_string objClass_var;
    opp_string objName_var;
    uint64 objInst_var;
    objVal_t objValue_var;
    uint32 result_var;
    uint32 scope_var;
    unsigned char authMech_var;
    authValue_t authValue_var;
    opp_string destAEInst_var;
    opp_string destAEName_var;
    opp_string destApInst_var;
    opp_string destApName_var;
    opp_string srcAEInst_var;
    opp_string srcAEName_var;
    opp_string srcApInst_var;
    opp_string srcApName_var;
    opp_string resultReason_var;
    int64 version_var;

  private:
    void copy(const CDAP_General_Message& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_General_Message&);

  public:
    CDAP_General_Message(const char *name=NULL, int kind=0);
    CDAP_General_Message(const CDAP_General_Message& other);
    virtual ~CDAP_General_Message();
    CDAP_General_Message& operator=(const CDAP_General_Message& other);
    virtual CDAP_General_Message *dup() const {return new CDAP_General_Message(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getAbsSyntax() const;
    virtual void setAbsSyntax(unsigned char absSyntax);
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual uint32 getInvokeID() const;
    virtual void setInvokeID(uint32 invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual const char * getObjClass() const;
    virtual void setObjClass(const char * objClass);
    virtual const char * getObjName() const;
    virtual void setObjName(const char * objName);
    virtual uint64 getObjInst() const;
    virtual void setObjInst(uint64 objInst);
    virtual objVal_t& getObjValue();
    virtual const objVal_t& getObjValue() const {return const_cast<CDAP_General_Message*>(this)->getObjValue();}
    virtual void setObjValue(const objVal_t& objValue);
    virtual uint32 getResult() const;
    virtual void setResult(uint32 result);
    virtual uint32 getScope() const;
    virtual void setScope(uint32 scope);
    virtual unsigned char getAuthMech() const;
    virtual void setAuthMech(unsigned char authMech);
    virtual authValue_t& getAuthValue();
    virtual const authValue_t& getAuthValue() const {return const_cast<CDAP_General_Message*>(this)->getAuthValue();}
    virtual void setAuthValue(const authValue_t& authValue);
    virtual const char * getDestAEInst() const;
    virtual void setDestAEInst(const char * destAEInst);
    virtual const char * getDestAEName() const;
    virtual void setDestAEName(const char * destAEName);
    virtual const char * getDestApInst() const;
    virtual void setDestApInst(const char * destApInst);
    virtual const char * getDestApName() const;
    virtual void setDestApName(const char * destApName);
    virtual const char * getSrcAEInst() const;
    virtual void setSrcAEInst(const char * srcAEInst);
    virtual const char * getSrcAEName() const;
    virtual void setSrcAEName(const char * srcAEName);
    virtual const char * getSrcApInst() const;
    virtual void setSrcApInst(const char * srcApInst);
    virtual const char * getSrcApName() const;
    virtual void setSrcApName(const char * srcApName);
    virtual const char * getResultReason() const;
    virtual void setResultReason(const char * resultReason);
    virtual int64 getVersion() const;
    virtual void setVersion(int64 version);
};

inline void doPacking(cCommBuffer *b, CDAP_General_Message& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_General_Message& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_Connect {	
 * 	unsigned char opCode enum(opCode_t) = M_CONNECT;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;		
 * 	int absSyntax enum(absSyntax_t);	
 * 	auth_t auth;	
 * 	naming_t src;
 * 	naming_t dst;
 * }
 * </pre>
 */
class CDAP_M_Connect : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    int absSyntax_var;
    auth_t auth_var;
    naming_t src_var;
    naming_t dst_var;

  private:
    void copy(const CDAP_M_Connect& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_Connect&);

  public:
    CDAP_M_Connect(const char *name=NULL, int kind=0);
    CDAP_M_Connect(const CDAP_M_Connect& other);
    virtual ~CDAP_M_Connect();
    CDAP_M_Connect& operator=(const CDAP_M_Connect& other);
    virtual CDAP_M_Connect *dup() const {return new CDAP_M_Connect(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual int getAbsSyntax() const;
    virtual void setAbsSyntax(int absSyntax);
    virtual auth_t& getAuth();
    virtual const auth_t& getAuth() const {return const_cast<CDAP_M_Connect*>(this)->getAuth();}
    virtual void setAuth(const auth_t& auth);
    virtual naming_t& getSrc();
    virtual const naming_t& getSrc() const {return const_cast<CDAP_M_Connect*>(this)->getSrc();}
    virtual void setSrc(const naming_t& src);
    virtual naming_t& getDst();
    virtual const naming_t& getDst() const {return const_cast<CDAP_M_Connect*>(this)->getDst();}
    virtual void setDst(const naming_t& dst);
};

inline void doPacking(cCommBuffer *b, CDAP_M_Connect& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_Connect& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_Connect_R {
 * 	unsigned char opCode enum(opCode_t) = M_CONNECT_R;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;		
 * 	result_t result;		   
 * 	int absSyntax enum(absSyntax_t);	
 * 	auth_t auth;	
 * 	naming_t src;
 * 	naming_t dst;
 * }
 * </pre>
 */
class CDAP_M_Connect_R : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    result_t result_var;
    int absSyntax_var;
    auth_t auth_var;
    naming_t src_var;
    naming_t dst_var;

  private:
    void copy(const CDAP_M_Connect_R& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_Connect_R&);

  public:
    CDAP_M_Connect_R(const char *name=NULL, int kind=0);
    CDAP_M_Connect_R(const CDAP_M_Connect_R& other);
    virtual ~CDAP_M_Connect_R();
    CDAP_M_Connect_R& operator=(const CDAP_M_Connect_R& other);
    virtual CDAP_M_Connect_R *dup() const {return new CDAP_M_Connect_R(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual result_t& getResult();
    virtual const result_t& getResult() const {return const_cast<CDAP_M_Connect_R*>(this)->getResult();}
    virtual void setResult(const result_t& result);
    virtual int getAbsSyntax() const;
    virtual void setAbsSyntax(int absSyntax);
    virtual auth_t& getAuth();
    virtual const auth_t& getAuth() const {return const_cast<CDAP_M_Connect_R*>(this)->getAuth();}
    virtual void setAuth(const auth_t& auth);
    virtual naming_t& getSrc();
    virtual const naming_t& getSrc() const {return const_cast<CDAP_M_Connect_R*>(this)->getSrc();}
    virtual void setSrc(const naming_t& src);
    virtual naming_t& getDst();
    virtual const naming_t& getDst() const {return const_cast<CDAP_M_Connect_R*>(this)->getDst();}
    virtual void setDst(const naming_t& dst);
};

inline void doPacking(cCommBuffer *b, CDAP_M_Connect_R& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_Connect_R& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_Release {
 * 	unsigned char opCode enum(opCode_t) = M_RELEASE;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;
 * }
 * </pre>
 */
class CDAP_M_Release : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;

  private:
    void copy(const CDAP_M_Release& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_Release&);

  public:
    CDAP_M_Release(const char *name=NULL, int kind=0);
    CDAP_M_Release(const CDAP_M_Release& other);
    virtual ~CDAP_M_Release();
    CDAP_M_Release& operator=(const CDAP_M_Release& other);
    virtual CDAP_M_Release *dup() const {return new CDAP_M_Release(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
};

inline void doPacking(cCommBuffer *b, CDAP_M_Release& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_Release& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_Release_R {
 * 	unsigned char opCode enum(opCode_t) = M_RELEASE_R;	
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;
 * 	result_t result;	
 * }
 * </pre>
 */
class CDAP_M_Release_R : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    result_t result_var;

  private:
    void copy(const CDAP_M_Release_R& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_Release_R&);

  public:
    CDAP_M_Release_R(const char *name=NULL, int kind=0);
    CDAP_M_Release_R(const CDAP_M_Release_R& other);
    virtual ~CDAP_M_Release_R();
    CDAP_M_Release_R& operator=(const CDAP_M_Release_R& other);
    virtual CDAP_M_Release_R *dup() const {return new CDAP_M_Release_R(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual result_t& getResult();
    virtual const result_t& getResult() const {return const_cast<CDAP_M_Release_R*>(this)->getResult();}
    virtual void setResult(const result_t& result);
};

inline void doPacking(cCommBuffer *b, CDAP_M_Release_R& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_Release_R& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_Create {
 * 	unsigned char opCode enum(opCode_t) = M_CREATE;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;	
 * 	object_t object;
 * 	int scope;
 * 	int filter;	
 * }
 * </pre>
 */
class CDAP_M_Create : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    object_t object_var;
    int scope_var;
    int filter_var;

  private:
    void copy(const CDAP_M_Create& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_Create&);

  public:
    CDAP_M_Create(const char *name=NULL, int kind=0);
    CDAP_M_Create(const CDAP_M_Create& other);
    virtual ~CDAP_M_Create();
    CDAP_M_Create& operator=(const CDAP_M_Create& other);
    virtual CDAP_M_Create *dup() const {return new CDAP_M_Create(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual object_t& getObject();
    virtual const object_t& getObject() const {return const_cast<CDAP_M_Create*>(this)->getObject();}
    virtual void setObject(const object_t& object);
    virtual int getScope() const;
    virtual void setScope(int scope);
    virtual int getFilter() const;
    virtual void setFilter(int filter);
};

inline void doPacking(cCommBuffer *b, CDAP_M_Create& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_Create& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_Create_R {
 * 	unsigned char opCode enum(opCode_t) = M_CREATE_R;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;	
 * 	result_t result;
 * 	object_t object;	
 * 	int filter;		
 * }
 * </pre>
 */
class CDAP_M_Create_R : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    result_t result_var;
    object_t object_var;
    int filter_var;

  private:
    void copy(const CDAP_M_Create_R& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_Create_R&);

  public:
    CDAP_M_Create_R(const char *name=NULL, int kind=0);
    CDAP_M_Create_R(const CDAP_M_Create_R& other);
    virtual ~CDAP_M_Create_R();
    CDAP_M_Create_R& operator=(const CDAP_M_Create_R& other);
    virtual CDAP_M_Create_R *dup() const {return new CDAP_M_Create_R(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual result_t& getResult();
    virtual const result_t& getResult() const {return const_cast<CDAP_M_Create_R*>(this)->getResult();}
    virtual void setResult(const result_t& result);
    virtual object_t& getObject();
    virtual const object_t& getObject() const {return const_cast<CDAP_M_Create_R*>(this)->getObject();}
    virtual void setObject(const object_t& object);
    virtual int getFilter() const;
    virtual void setFilter(int filter);
};

inline void doPacking(cCommBuffer *b, CDAP_M_Create_R& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_Create_R& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_Delete {
 * 	unsigned char opCode enum(opCode_t) = M_DELETE;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;	
 * 	object_t object;
 * 	int scope;
 * 	int filter;		
 * }
 * </pre>
 */
class CDAP_M_Delete : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    object_t object_var;
    int scope_var;
    int filter_var;

  private:
    void copy(const CDAP_M_Delete& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_Delete&);

  public:
    CDAP_M_Delete(const char *name=NULL, int kind=0);
    CDAP_M_Delete(const CDAP_M_Delete& other);
    virtual ~CDAP_M_Delete();
    CDAP_M_Delete& operator=(const CDAP_M_Delete& other);
    virtual CDAP_M_Delete *dup() const {return new CDAP_M_Delete(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual object_t& getObject();
    virtual const object_t& getObject() const {return const_cast<CDAP_M_Delete*>(this)->getObject();}
    virtual void setObject(const object_t& object);
    virtual int getScope() const;
    virtual void setScope(int scope);
    virtual int getFilter() const;
    virtual void setFilter(int filter);
};

inline void doPacking(cCommBuffer *b, CDAP_M_Delete& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_Delete& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_Delete_R {
 * 	unsigned char opCode enum(opCode_t) = M_DELETE_R;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;	
 * 	result_t result;
 * 	object_t object;
 * 	int filter;		
 * }
 * </pre>
 */
class CDAP_M_Delete_R : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    result_t result_var;
    object_t object_var;
    int filter_var;

  private:
    void copy(const CDAP_M_Delete_R& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_Delete_R&);

  public:
    CDAP_M_Delete_R(const char *name=NULL, int kind=0);
    CDAP_M_Delete_R(const CDAP_M_Delete_R& other);
    virtual ~CDAP_M_Delete_R();
    CDAP_M_Delete_R& operator=(const CDAP_M_Delete_R& other);
    virtual CDAP_M_Delete_R *dup() const {return new CDAP_M_Delete_R(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual result_t& getResult();
    virtual const result_t& getResult() const {return const_cast<CDAP_M_Delete_R*>(this)->getResult();}
    virtual void setResult(const result_t& result);
    virtual object_t& getObject();
    virtual const object_t& getObject() const {return const_cast<CDAP_M_Delete_R*>(this)->getObject();}
    virtual void setObject(const object_t& object);
    virtual int getFilter() const;
    virtual void setFilter(int filter);
};

inline void doPacking(cCommBuffer *b, CDAP_M_Delete_R& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_Delete_R& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_Read {
 * 	unsigned char opCode enum(opCode_t) = M_READ;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;
 * 	object_t object;
 * 	int scope;
 * 	int filter;			
 * }
 * </pre>
 */
class CDAP_M_Read : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    object_t object_var;
    int scope_var;
    int filter_var;

  private:
    void copy(const CDAP_M_Read& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_Read&);

  public:
    CDAP_M_Read(const char *name=NULL, int kind=0);
    CDAP_M_Read(const CDAP_M_Read& other);
    virtual ~CDAP_M_Read();
    CDAP_M_Read& operator=(const CDAP_M_Read& other);
    virtual CDAP_M_Read *dup() const {return new CDAP_M_Read(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual object_t& getObject();
    virtual const object_t& getObject() const {return const_cast<CDAP_M_Read*>(this)->getObject();}
    virtual void setObject(const object_t& object);
    virtual int getScope() const;
    virtual void setScope(int scope);
    virtual int getFilter() const;
    virtual void setFilter(int filter);
};

inline void doPacking(cCommBuffer *b, CDAP_M_Read& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_Read& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_Read_R {
 * 	unsigned char opCode enum(opCode_t) = M_READ_R;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;	
 * 	result_t result;
 * 	object_t object;
 * 	int filter;		
 * }
 * </pre>
 */
class CDAP_M_Read_R : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    result_t result_var;
    object_t object_var;
    int filter_var;

  private:
    void copy(const CDAP_M_Read_R& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_Read_R&);

  public:
    CDAP_M_Read_R(const char *name=NULL, int kind=0);
    CDAP_M_Read_R(const CDAP_M_Read_R& other);
    virtual ~CDAP_M_Read_R();
    CDAP_M_Read_R& operator=(const CDAP_M_Read_R& other);
    virtual CDAP_M_Read_R *dup() const {return new CDAP_M_Read_R(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual result_t& getResult();
    virtual const result_t& getResult() const {return const_cast<CDAP_M_Read_R*>(this)->getResult();}
    virtual void setResult(const result_t& result);
    virtual object_t& getObject();
    virtual const object_t& getObject() const {return const_cast<CDAP_M_Read_R*>(this)->getObject();}
    virtual void setObject(const object_t& object);
    virtual int getFilter() const;
    virtual void setFilter(int filter);
};

inline void doPacking(cCommBuffer *b, CDAP_M_Read_R& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_Read_R& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_CancelRead {
 * 	unsigned char opCode enum(opCode_t) = M_CANCELREAD;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;
 * 	result_t result;
 * }
 * </pre>
 */
class CDAP_M_CancelRead : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    result_t result_var;

  private:
    void copy(const CDAP_M_CancelRead& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_CancelRead&);

  public:
    CDAP_M_CancelRead(const char *name=NULL, int kind=0);
    CDAP_M_CancelRead(const CDAP_M_CancelRead& other);
    virtual ~CDAP_M_CancelRead();
    CDAP_M_CancelRead& operator=(const CDAP_M_CancelRead& other);
    virtual CDAP_M_CancelRead *dup() const {return new CDAP_M_CancelRead(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual result_t& getResult();
    virtual const result_t& getResult() const {return const_cast<CDAP_M_CancelRead*>(this)->getResult();}
    virtual void setResult(const result_t& result);
};

inline void doPacking(cCommBuffer *b, CDAP_M_CancelRead& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_CancelRead& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_CancelRead_R {
 * 	unsigned char opCode enum(opCode_t) = M_CANCELREAD_R;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;	
 * 	result_t result;	
 * }
 * </pre>
 */
class CDAP_M_CancelRead_R : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    result_t result_var;

  private:
    void copy(const CDAP_M_CancelRead_R& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_CancelRead_R&);

  public:
    CDAP_M_CancelRead_R(const char *name=NULL, int kind=0);
    CDAP_M_CancelRead_R(const CDAP_M_CancelRead_R& other);
    virtual ~CDAP_M_CancelRead_R();
    CDAP_M_CancelRead_R& operator=(const CDAP_M_CancelRead_R& other);
    virtual CDAP_M_CancelRead_R *dup() const {return new CDAP_M_CancelRead_R(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual result_t& getResult();
    virtual const result_t& getResult() const {return const_cast<CDAP_M_CancelRead_R*>(this)->getResult();}
    virtual void setResult(const result_t& result);
};

inline void doPacking(cCommBuffer *b, CDAP_M_CancelRead_R& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_CancelRead_R& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_Write {
 * 	unsigned char opCode enum(opCode_t) = M_WRITE;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;
 * 	object_t object;
 * 	int scope;
 * 	int filter;					
 * }
 * </pre>
 */
class CDAP_M_Write : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    object_t object_var;
    int scope_var;
    int filter_var;

  private:
    void copy(const CDAP_M_Write& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_Write&);

  public:
    CDAP_M_Write(const char *name=NULL, int kind=0);
    CDAP_M_Write(const CDAP_M_Write& other);
    virtual ~CDAP_M_Write();
    CDAP_M_Write& operator=(const CDAP_M_Write& other);
    virtual CDAP_M_Write *dup() const {return new CDAP_M_Write(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual object_t& getObject();
    virtual const object_t& getObject() const {return const_cast<CDAP_M_Write*>(this)->getObject();}
    virtual void setObject(const object_t& object);
    virtual int getScope() const;
    virtual void setScope(int scope);
    virtual int getFilter() const;
    virtual void setFilter(int filter);
};

inline void doPacking(cCommBuffer *b, CDAP_M_Write& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_Write& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_Write_R {
 * 	unsigned char opCode enum(opCode_t) = M_WRITE_R;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;	
 * 	result_t result;
 * 	object_t object;
 * 	int filter;			
 * }
 * </pre>
 */
class CDAP_M_Write_R : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    result_t result_var;
    object_t object_var;
    int filter_var;

  private:
    void copy(const CDAP_M_Write_R& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_Write_R&);

  public:
    CDAP_M_Write_R(const char *name=NULL, int kind=0);
    CDAP_M_Write_R(const CDAP_M_Write_R& other);
    virtual ~CDAP_M_Write_R();
    CDAP_M_Write_R& operator=(const CDAP_M_Write_R& other);
    virtual CDAP_M_Write_R *dup() const {return new CDAP_M_Write_R(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual result_t& getResult();
    virtual const result_t& getResult() const {return const_cast<CDAP_M_Write_R*>(this)->getResult();}
    virtual void setResult(const result_t& result);
    virtual object_t& getObject();
    virtual const object_t& getObject() const {return const_cast<CDAP_M_Write_R*>(this)->getObject();}
    virtual void setObject(const object_t& object);
    virtual int getFilter() const;
    virtual void setFilter(int filter);
};

inline void doPacking(cCommBuffer *b, CDAP_M_Write_R& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_Write_R& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_Start {
 * 	unsigned char opCode enum(opCode_t) = M_START;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;
 * 	object_t object;
 * 	int scope;
 * 	int filter;		
 * }
 * </pre>
 */
class CDAP_M_Start : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    object_t object_var;
    int scope_var;
    int filter_var;

  private:
    void copy(const CDAP_M_Start& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_Start&);

  public:
    CDAP_M_Start(const char *name=NULL, int kind=0);
    CDAP_M_Start(const CDAP_M_Start& other);
    virtual ~CDAP_M_Start();
    CDAP_M_Start& operator=(const CDAP_M_Start& other);
    virtual CDAP_M_Start *dup() const {return new CDAP_M_Start(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual object_t& getObject();
    virtual const object_t& getObject() const {return const_cast<CDAP_M_Start*>(this)->getObject();}
    virtual void setObject(const object_t& object);
    virtual int getScope() const;
    virtual void setScope(int scope);
    virtual int getFilter() const;
    virtual void setFilter(int filter);
};

inline void doPacking(cCommBuffer *b, CDAP_M_Start& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_Start& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_Start_R {
 * 	unsigned char opCode enum(opCode_t) = M_START_R;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;	
 * 	result_t result;
 * 	object_t object;
 * 	int filter;		
 * }
 * </pre>
 */
class CDAP_M_Start_R : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    result_t result_var;
    object_t object_var;
    int filter_var;

  private:
    void copy(const CDAP_M_Start_R& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_Start_R&);

  public:
    CDAP_M_Start_R(const char *name=NULL, int kind=0);
    CDAP_M_Start_R(const CDAP_M_Start_R& other);
    virtual ~CDAP_M_Start_R();
    CDAP_M_Start_R& operator=(const CDAP_M_Start_R& other);
    virtual CDAP_M_Start_R *dup() const {return new CDAP_M_Start_R(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual result_t& getResult();
    virtual const result_t& getResult() const {return const_cast<CDAP_M_Start_R*>(this)->getResult();}
    virtual void setResult(const result_t& result);
    virtual object_t& getObject();
    virtual const object_t& getObject() const {return const_cast<CDAP_M_Start_R*>(this)->getObject();}
    virtual void setObject(const object_t& object);
    virtual int getFilter() const;
    virtual void setFilter(int filter);
};

inline void doPacking(cCommBuffer *b, CDAP_M_Start_R& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_Start_R& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_Stop {
 * 	unsigned char opCode enum(opCode_t) = M_STOP;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;	
 * 	object_t object;
 * 	int scope;
 * 	int filter;		
 * 	
 * }
 * </pre>
 */
class CDAP_M_Stop : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    object_t object_var;
    int scope_var;
    int filter_var;

  private:
    void copy(const CDAP_M_Stop& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_Stop&);

  public:
    CDAP_M_Stop(const char *name=NULL, int kind=0);
    CDAP_M_Stop(const CDAP_M_Stop& other);
    virtual ~CDAP_M_Stop();
    CDAP_M_Stop& operator=(const CDAP_M_Stop& other);
    virtual CDAP_M_Stop *dup() const {return new CDAP_M_Stop(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual object_t& getObject();
    virtual const object_t& getObject() const {return const_cast<CDAP_M_Stop*>(this)->getObject();}
    virtual void setObject(const object_t& object);
    virtual int getScope() const;
    virtual void setScope(int scope);
    virtual int getFilter() const;
    virtual void setFilter(int filter);
};

inline void doPacking(cCommBuffer *b, CDAP_M_Stop& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_Stop& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DAF/CDAP/CDAPMessage.msg</tt> by opp_msgc.
 * <pre>
 * message CDAP_M_Stop_R {
 * 	unsigned char opCode enum(opCode_t) = M_STOP_R;
 * 	int invokeID;	
 * 	unsigned char flags enum(flagValues_t);
 * 	int version;	
 * 	result_t result;
 * 	object_t object;
 * 	int filter;			
 * }
 * </pre>
 */
class CDAP_M_Stop_R : public ::cMessage
{
  protected:
    unsigned char opCode_var;
    int invokeID_var;
    unsigned char flags_var;
    int version_var;
    result_t result_var;
    object_t object_var;
    int filter_var;

  private:
    void copy(const CDAP_M_Stop_R& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CDAP_M_Stop_R&);

  public:
    CDAP_M_Stop_R(const char *name=NULL, int kind=0);
    CDAP_M_Stop_R(const CDAP_M_Stop_R& other);
    virtual ~CDAP_M_Stop_R();
    CDAP_M_Stop_R& operator=(const CDAP_M_Stop_R& other);
    virtual CDAP_M_Stop_R *dup() const {return new CDAP_M_Stop_R(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getOpCode() const;
    virtual void setOpCode(unsigned char opCode);
    virtual int getInvokeID() const;
    virtual void setInvokeID(int invokeID);
    virtual unsigned char getFlags() const;
    virtual void setFlags(unsigned char flags);
    virtual int getVersion() const;
    virtual void setVersion(int version);
    virtual result_t& getResult();
    virtual const result_t& getResult() const {return const_cast<CDAP_M_Stop_R*>(this)->getResult();}
    virtual void setResult(const result_t& result);
    virtual object_t& getObject();
    virtual const object_t& getObject() const {return const_cast<CDAP_M_Stop_R*>(this)->getObject();}
    virtual void setObject(const object_t& object);
    virtual int getFilter() const;
    virtual void setFilter(int filter);
};

inline void doPacking(cCommBuffer *b, CDAP_M_Stop_R& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CDAP_M_Stop_R& obj) {obj.parsimUnpack(b);}


#endif // _CDAPMESSAGE_M_H_
