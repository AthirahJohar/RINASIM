//
// Generated file, do not edit! Created by opp_msgc 4.5 from DIF/EFCP/ControlPDU.msg.
//

#ifndef _CONTROLPDU_M_H_
#define _CONTROLPDU_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0405
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif

// cplusplus {{
#include "PDU.h"
// }}



/**
 * Class generated from <tt>DIF/EFCP/ControlPDU.msg</tt> by opp_msgc.
 * <pre>
 * packet ControlPDU extends PDU{
 *     unsigned int controlSeqNum;
 * }
 * </pre>
 */
class ControlPDU : public ::PDU
{
  protected:
    unsigned int controlSeqNum_var;

  private:
    void copy(const ControlPDU& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ControlPDU&);

  public:
    ControlPDU(const char *name=NULL, int kind=0);
    ControlPDU(const ControlPDU& other);
    virtual ~ControlPDU();
    ControlPDU& operator=(const ControlPDU& other);
    virtual ControlPDU *dup() const {return new ControlPDU(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getControlSeqNum() const;
    virtual void setControlSeqNum(unsigned int controlSeqNum);
};

inline void doPacking(cCommBuffer *b, ControlPDU& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ControlPDU& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DIF/EFCP/ControlPDU.msg</tt> by opp_msgc.
 * <pre>
 * packet FlowControlPDU extends ControlPDU {
 *     
 * 	
 *     unsigned int rateLen;
 *     unsigned int timeUnit;
 *     unsigned int myLeftWinEdge;
 *     unsigned int myRightWinEdge;
 *     unsigned int myRcvRate;
 * }
 * </pre>
 */
class FlowControlPDU : public ::ControlPDU
{
  protected:
    unsigned int rateLen_var;
    unsigned int timeUnit_var;
    unsigned int myLeftWinEdge_var;
    unsigned int myRightWinEdge_var;
    unsigned int myRcvRate_var;

  private:
    void copy(const FlowControlPDU& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FlowControlPDU&);

  public:
    FlowControlPDU(const char *name=NULL, int kind=0);
    FlowControlPDU(const FlowControlPDU& other);
    virtual ~FlowControlPDU();
    FlowControlPDU& operator=(const FlowControlPDU& other);
    virtual FlowControlPDU *dup() const {return new FlowControlPDU(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getRateLen() const;
    virtual void setRateLen(unsigned int rateLen);
    virtual unsigned int getTimeUnit() const;
    virtual void setTimeUnit(unsigned int timeUnit);
    virtual unsigned int getMyLeftWinEdge() const;
    virtual void setMyLeftWinEdge(unsigned int myLeftWinEdge);
    virtual unsigned int getMyRightWinEdge() const;
    virtual void setMyRightWinEdge(unsigned int myRightWinEdge);
    virtual unsigned int getMyRcvRate() const;
    virtual void setMyRcvRate(unsigned int myRcvRate);
};

inline void doPacking(cCommBuffer *b, FlowControlPDU& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FlowControlPDU& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DIF/EFCP/ControlPDU.msg</tt> by opp_msgc.
 * <pre>
 * packet NAckPDU extends ControlPDU{
 *     unsigned int ackNackSeqNum;
 *     type = -1;
 * }
 * </pre>
 */
class NAckPDU : public ::ControlPDU
{
  protected:
    unsigned int ackNackSeqNum_var;

  private:
    void copy(const NAckPDU& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NAckPDU&);

  public:
    NAckPDU(const char *name=NULL, int kind=0);
    NAckPDU(const NAckPDU& other);
    virtual ~NAckPDU();
    NAckPDU& operator=(const NAckPDU& other);
    virtual NAckPDU *dup() const {return new NAckPDU(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getAckNackSeqNum() const;
    virtual void setAckNackSeqNum(unsigned int ackNackSeqNum);
};

inline void doPacking(cCommBuffer *b, NAckPDU& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NAckPDU& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DIF/EFCP/ControlPDU.msg</tt> by opp_msgc.
 * <pre>
 * packet AckOnlyPDU extends NAckPDU{
 *     type = ACK_ONLY_PDU;
 * }
 * </pre>
 */
class AckOnlyPDU : public ::NAckPDU
{
  protected:

  private:
    void copy(const AckOnlyPDU& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const AckOnlyPDU&);

  public:
    AckOnlyPDU(const char *name=NULL, int kind=0);
    AckOnlyPDU(const AckOnlyPDU& other);
    virtual ~AckOnlyPDU();
    AckOnlyPDU& operator=(const AckOnlyPDU& other);
    virtual AckOnlyPDU *dup() const {return new AckOnlyPDU(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, AckOnlyPDU& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, AckOnlyPDU& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DIF/EFCP/ControlPDU.msg</tt> by opp_msgc.
 * <pre>
 * packet NackOnlyPDU extends NAckPDU{
 *     type = NACK_ONLY_PDU;
 * }
 * </pre>
 */
class NackOnlyPDU : public ::NAckPDU
{
  protected:

  private:
    void copy(const NackOnlyPDU& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NackOnlyPDU&);

  public:
    NackOnlyPDU(const char *name=NULL, int kind=0);
    NackOnlyPDU(const NackOnlyPDU& other);
    virtual ~NackOnlyPDU();
    NackOnlyPDU& operator=(const NackOnlyPDU& other);
    virtual NackOnlyPDU *dup() const {return new NackOnlyPDU(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, NackOnlyPDU& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NackOnlyPDU& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DIF/EFCP/ControlPDU.msg</tt> by opp_msgc.
 * <pre>
 * packet NAck extends NAckPDU{
 *     
 * }
 * </pre>
 */
class NAck : public ::NAckPDU
{
  protected:

  private:
    void copy(const NAck& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NAck&);

  public:
    NAck(const char *name=NULL, int kind=0);
    NAck(const NAck& other);
    virtual ~NAck();
    NAck& operator=(const NAck& other);
    virtual NAck *dup() const {return new NAck(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, NAck& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NAck& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DIF/EFCP/ControlPDU.msg</tt> by opp_msgc.
 * <pre>
 * packet NAckFlow extends FlowControlPDU{
 *     
 * }
 * </pre>
 */
class NAckFlow : public ::FlowControlPDU
{
  protected:

  private:
    void copy(const NAckFlow& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NAckFlow&);

  public:
    NAckFlow(const char *name=NULL, int kind=0);
    NAckFlow(const NAckFlow& other);
    virtual ~NAckFlow();
    NAckFlow& operator=(const NAckFlow& other);
    virtual NAckFlow *dup() const {return new NAckFlow(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, NAckFlow& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NAckFlow& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DIF/EFCP/ControlPDU.msg</tt> by opp_msgc.
 * <pre>
 * packet AckFlowPDU extends NAckFlow{
 *     type = ACK_FLOW_PDU;
 * }
 * </pre>
 */
class AckFlowPDU : public ::NAckFlow
{
  protected:

  private:
    void copy(const AckFlowPDU& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const AckFlowPDU&);

  public:
    AckFlowPDU(const char *name=NULL, int kind=0);
    AckFlowPDU(const AckFlowPDU& other);
    virtual ~AckFlowPDU();
    AckFlowPDU& operator=(const AckFlowPDU& other);
    virtual AckFlowPDU *dup() const {return new AckFlowPDU(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, AckFlowPDU& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, AckFlowPDU& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DIF/EFCP/ControlPDU.msg</tt> by opp_msgc.
 * <pre>
 * packet NackFlowPDU extends NAckFlow{
 *     type = NACK_FLOW_PDU;
 * }
 * </pre>
 */
class NackFlowPDU : public ::NAckFlow
{
  protected:

  private:
    void copy(const NackFlowPDU& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NackFlowPDU&);

  public:
    NackFlowPDU(const char *name=NULL, int kind=0);
    NackFlowPDU(const NackFlowPDU& other);
    virtual ~NackFlowPDU();
    NackFlowPDU& operator=(const NackFlowPDU& other);
    virtual NackFlowPDU *dup() const {return new NackFlowPDU(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, NackFlowPDU& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, NackFlowPDU& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DIF/EFCP/ControlPDU.msg</tt> by opp_msgc.
 * <pre>
 * packet FlowControlOnlyPDU extends FlowControlPDU{
 *     type = FLOW_ONLY_PDU;
 * }
 * </pre>
 */
class FlowControlOnlyPDU : public ::FlowControlPDU
{
  protected:

  private:
    void copy(const FlowControlOnlyPDU& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const FlowControlOnlyPDU&);

  public:
    FlowControlOnlyPDU(const char *name=NULL, int kind=0);
    FlowControlOnlyPDU(const FlowControlOnlyPDU& other);
    virtual ~FlowControlOnlyPDU();
    FlowControlOnlyPDU& operator=(const FlowControlOnlyPDU& other);
    virtual FlowControlOnlyPDU *dup() const {return new FlowControlOnlyPDU(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, FlowControlOnlyPDU& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, FlowControlOnlyPDU& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DIF/EFCP/ControlPDU.msg</tt> by opp_msgc.
 * <pre>
 * packet SelectiveNAckFlow extends FlowControlPDU{
 *     unsigned int newLeftWinEdge;
 *     unsigned int newRightWinEdge;
 *     
 *     unsigned int nackListLen;
 *     unsigned int nackList [];
 * }
 * </pre>
 */
class SelectiveNAckFlow : public ::FlowControlPDU
{
  protected:
    unsigned int newLeftWinEdge_var;
    unsigned int newRightWinEdge_var;
    unsigned int nackListLen_var;
    unsigned int *nackList_var; // array ptr
    unsigned int nackList_arraysize;

  private:
    void copy(const SelectiveNAckFlow& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SelectiveNAckFlow&);

  public:
    SelectiveNAckFlow(const char *name=NULL, int kind=0);
    SelectiveNAckFlow(const SelectiveNAckFlow& other);
    virtual ~SelectiveNAckFlow();
    SelectiveNAckFlow& operator=(const SelectiveNAckFlow& other);
    virtual SelectiveNAckFlow *dup() const {return new SelectiveNAckFlow(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getNewLeftWinEdge() const;
    virtual void setNewLeftWinEdge(unsigned int newLeftWinEdge);
    virtual unsigned int getNewRightWinEdge() const;
    virtual void setNewRightWinEdge(unsigned int newRightWinEdge);
    virtual unsigned int getNackListLen() const;
    virtual void setNackListLen(unsigned int nackListLen);
    virtual void setNackListArraySize(unsigned int size);
    virtual unsigned int getNackListArraySize() const;
    virtual unsigned int getNackList(unsigned int k) const;
    virtual void setNackList(unsigned int k, unsigned int nackList);
};

inline void doPacking(cCommBuffer *b, SelectiveNAckFlow& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SelectiveNAckFlow& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DIF/EFCP/ControlPDU.msg</tt> by opp_msgc.
 * <pre>
 * packet SelectiveAckFlowPDU extends SelectiveNAckFlow{
 *     type = SELECT_ACK_FLOW_PDU;
 * }
 * </pre>
 */
class SelectiveAckFlowPDU : public ::SelectiveNAckFlow
{
  protected:

  private:
    void copy(const SelectiveAckFlowPDU& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SelectiveAckFlowPDU&);

  public:
    SelectiveAckFlowPDU(const char *name=NULL, int kind=0);
    SelectiveAckFlowPDU(const SelectiveAckFlowPDU& other);
    virtual ~SelectiveAckFlowPDU();
    SelectiveAckFlowPDU& operator=(const SelectiveAckFlowPDU& other);
    virtual SelectiveAckFlowPDU *dup() const {return new SelectiveAckFlowPDU(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, SelectiveAckFlowPDU& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SelectiveAckFlowPDU& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DIF/EFCP/ControlPDU.msg</tt> by opp_msgc.
 * <pre>
 * packet SelectiveNackFlowPDU extends SelectiveNAckFlow{
 *     type = SELECT_NACK_FLOW_PDU;
 * }
 * </pre>
 */
class SelectiveNackFlowPDU : public ::SelectiveNAckFlow
{
  protected:

  private:
    void copy(const SelectiveNackFlowPDU& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SelectiveNackFlowPDU&);

  public:
    SelectiveNackFlowPDU(const char *name=NULL, int kind=0);
    SelectiveNackFlowPDU(const SelectiveNackFlowPDU& other);
    virtual ~SelectiveNackFlowPDU();
    SelectiveNackFlowPDU& operator=(const SelectiveNackFlowPDU& other);
    virtual SelectiveNackFlowPDU *dup() const {return new SelectiveNackFlowPDU(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, SelectiveNackFlowPDU& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SelectiveNackFlowPDU& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DIF/EFCP/ControlPDU.msg</tt> by opp_msgc.
 * <pre>
 * packet SelectiveAckPDU extends SelectiveNAckFlow{
 *     type = SELECT_ACK_PDU;
 * }
 * </pre>
 */
class SelectiveAckPDU : public ::SelectiveNAckFlow
{
  protected:

  private:
    void copy(const SelectiveAckPDU& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SelectiveAckPDU&);

  public:
    SelectiveAckPDU(const char *name=NULL, int kind=0);
    SelectiveAckPDU(const SelectiveAckPDU& other);
    virtual ~SelectiveAckPDU();
    SelectiveAckPDU& operator=(const SelectiveAckPDU& other);
    virtual SelectiveAckPDU *dup() const {return new SelectiveAckPDU(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, SelectiveAckPDU& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SelectiveAckPDU& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>DIF/EFCP/ControlPDU.msg</tt> by opp_msgc.
 * <pre>
 * packet SelectiveNackPDU extends SelectiveNAckFlow{
 *     type = SELECT_NACK_PDU;
 * }
 * </pre>
 */
class SelectiveNackPDU : public ::SelectiveNAckFlow
{
  protected:

  private:
    void copy(const SelectiveNackPDU& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SelectiveNackPDU&);

  public:
    SelectiveNackPDU(const char *name=NULL, int kind=0);
    SelectiveNackPDU(const SelectiveNackPDU& other);
    virtual ~SelectiveNackPDU();
    SelectiveNackPDU& operator=(const SelectiveNackPDU& other);
    virtual SelectiveNackPDU *dup() const {return new SelectiveNackPDU(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, SelectiveNackPDU& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SelectiveNackPDU& obj) {obj.parsimUnpack(b);}


#endif // _CONTROLPDU_M_H_
